<!-- templates/timeseries/results.html -->

{% extends 'base.html' %}
{% load static %}

{% block title %}Results - Timeseries Pipeline{% endblock %}

{% block content %}
<h1 class="mb-4">Analysis Results</h1>

<div class="mt-4">
    <button id="download-data-btn" class="btn btn-secondary">Download Raw Data</button>
</div>

<div id="no-results" class="alert alert-warning" style="display: none;">
    <p>No analysis results found. Please run an analysis first.</p>
    <a href="{% url 'timeseries:analysis' %}" class="btn btn-primary">Go to Analysis</a>
</div>

<div id="results-container" style="display: none;">
    <ul class="nav nav-tabs mb-4" id="resultsTabs" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="time-series-tab" data-bs-toggle="tab" data-bs-target="#time-series" 
                    type="button" role="tab" aria-controls="time-series" aria-selected="true">
                Time Series
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="stationarity-tab" data-bs-toggle="tab" data-bs-target="#stationarity" 
                    type="button" role="tab" aria-controls="stationarity" aria-selected="false">
                Stationarity
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="arima-tab" data-bs-toggle="tab" data-bs-target="#arima" 
                    type="button" role="tab" aria-controls="arima" aria-selected="false">
                ARIMA
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="garch-tab" data-bs-toggle="tab" data-bs-target="#garch" 
                    type="button" role="tab" aria-controls="garch" aria-selected="false">
                GARCH
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="data-tab" data-bs-toggle="tab" data-bs-target="#data" 
                    type="button" role="tab" aria-controls="data" aria-selected="false">
                Provenance
            </button>
        </li>
    </ul>
    
    <div class="tab-content" id="resultsTabsContent">
        <!-- Time Series Tab -->
        <div class="tab-pane fade show active" id="time-series" role="tabpanel" aria-labelledby="time-series-tab">
            <!-- Price Series Plot -->
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Price Series</h5>
                </div>
                <div class="card-body">
                    <div id="price-series-plot" style="height: 400px;"></div>
                </div>
            </div>
            
            <!-- Returns Series Plot -->
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Returns Series</h5>
                </div>
                <div class="card-body">
                    <div id="returns-series-plot" style="height: 400px;"></div>
                </div>
            </div>
            
            <!-- GARCH Series Plot -->
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Scaled for GARCH Series</h5>
                </div>
                <div class="card-body">
                    <div id="garch-series-plot" style="height: 400px;"></div>
                </div>
            </div>
        </div>
        
        <!-- Stationarity Tab -->
        <div class="tab-pane fade" id="stationarity" role="tabpanel" aria-labelledby="stationarity-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">Stationarity Test Results</h5>
                </div>
                <div class="card-body">
                    <div class="alert" id="stationarity-alert">
                        <strong>Interpretation:</strong> <span id="stationarity-interpretation"></span>
                    </div>
                    
                    <h6>ADF Test Results</h6>
                    <table class="table table-bordered">
                        <tbody>
                            <tr>
                                <th>ADF Statistic</th>
                                <td id="adf-statistic"></td>
                            </tr>
                            <tr>
                                <th>p-value</th>
                                <td id="p-value"></td>
                            </tr>
                            <tr>
                                <th>Is Stationary</th>
                                <td id="is-stationary"></td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <h6>Critical Values</h6>
                    <table class="table table-bordered" id="critical-values-table">
                        <thead>
                            <tr>
                                <th>Significance Level</th>
                                <th>Critical Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Will be filled dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- ARIMA Tab -->
        <div class="tab-pane fade" id="arima" role="tabpanel" aria-labelledby="arima-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">ARIMA Model Results</h5>
                </div>
                <div class="card-body">
                    <h6>Model Summary</h6>
                    <pre id="arima-summary" class="p-3 bg-light rounded"></pre>
                    
                    <h6>Forecast</h6>
                    <div id="arima-forecast-plot" style="height: 400px;"></div>
                </div>
            </div>
        </div>
        
        <!-- GARCH Tab -->
        <div class="tab-pane fade" id="garch" role="tabpanel" aria-labelledby="garch-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">GARCH Model Results</h5>
                </div>
                <div class="card-body">
                    <h6>Model Summary</h6>
                    <pre id="garch-summary" class="p-3 bg-light rounded"></pre>
                    
                    <h6>Volatility Forecast</h6>
                    <div id="garch-forecast-plot" style="height: 400px;"></div>
                </div>
            </div>
        </div>
        
        <!-- Provenance Tab -->
        <div class="tab-pane fade" id="data" role="tabpanel" aria-labelledby="data-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <ul class="nav nav-tabs card-header-tabs" id="datasetTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="price-data-tab" data-bs-toggle="tab" data-bs-target="#price-data" 
                                    type="button" role="tab" aria-controls="price-data" aria-selected="true">
                                Price Series
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="returns-data-tab" data-bs-toggle="tab" data-bs-target="#returns-data" 
                                    type="button" role="tab" aria-controls="returns-data" aria-selected="false">
                                Returns Series
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="garch-data-tab" data-bs-toggle="tab" data-bs-target="#garch-data" 
                                    type="button" role="tab" aria-controls="garch-data" aria-selected="false">
                                Scaled for GARCH
                            </button>
                        </li>
                    </ul>
                </div>
                <div class="card-body">
                    <div class="tab-content" id="datasetTabContent">
                        <!-- Price Series Data -->
                        <div class="tab-pane fade show active" id="price-data" role="tabpanel" aria-labelledby="price-data-tab">
                            <div class="d-flex justify-content-end mb-3">
                                <button class="btn btn-outline-primary" id="export-price-csv">
                                    <i class="bi bi-download"></i> Export as CSV
                                </button>
                            </div>
                            <div class="table-responsive">
                                <table class="table table-striped table-hover" id="price-data-table">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <!-- Dynamically filled -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Dynamically filled -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- Returns Series Data -->
                        <div class="tab-pane fade" id="returns-data" role="tabpanel" aria-labelledby="returns-data-tab">
                            <div class="d-flex justify-content-end mb-3">
                                <button class="btn btn-outline-primary" id="export-returns-csv">
                                    <i class="bi bi-download"></i> Export as CSV
                                </button>
                            </div>
                            <div class="table-responsive">
                                <table class="table table-striped table-hover" id="returns-data-table">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <!-- Dynamically filled -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Dynamically filled -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- GARCH Series Data -->
                        <div class="tab-pane fade" id="garch-data" role="tabpanel" aria-labelledby="garch-data-tab">
                            <div class="d-flex justify-content-end mb-3">
                                <button class="btn btn-outline-primary" id="export-garch-csv">
                                    <i class="bi bi-download"></i> Export as CSV
                                </button>
                            </div>
                            <div class="table-responsive">
                                <table class="table table-striped table-hover" id="garch-data-table">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <!-- Dynamically filled -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Dynamically filled -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
document.addEventListener('DOMContentLoaded', function() {

    console.log("Raw results data:", JSON.parse(sessionStorage.getItem('analysisResults')));

    // Try to get analysis results from sessionStorage
    const resultsJson = sessionStorage.getItem('analysisResults');

    if (!resultsJson) {
        // No results found, show message
        document.getElementById('no-results').style.display = 'block';
        document.getElementById('results-container').style.display = 'none';
        return;
    }
    
    // Parse results JSON
    const results = JSON.parse(resultsJson);
    console.log("Results data:", results);
    
    // Show results container
    document.getElementById('no-results').style.display = 'none';
    document.getElementById('results-container').style.display = 'block';
    
    // Helper function to transform array data into the format needed for plotting
    function transformArrayToPlotData(dataArray, dateField = 'Date') {
        if (!dataArray || !Array.isArray(dataArray) || dataArray.length === 0) {
            console.error("Invalid data array:", dataArray);
            return null;
        }
        
        // Get all symbols (exclude the date field)
        const firstItem = dataArray[0];
        const symbols = Object.keys(firstItem).filter(key => key !== dateField);
        
        if (symbols.length === 0) {
            console.error("No symbols found in data");
            return null;
        }
        
        console.log("Found symbols:", symbols);
        
        // Create plot data for each symbol
        const plotData = symbols.map(symbol => {
            const x = [];
            const y = [];
            
            // Collect data points for this symbol
            dataArray.forEach(item => {
                if (item[symbol] !== undefined) {
                    // Get date from the date field (removing time part if present)
                    const date = item[dateField].split('T')[0];
                    x.push(date);
                    y.push(item[symbol]);
                }
            });
            
            return {
                x: x,
                y: y,
                type: 'scatter',
                mode: 'lines',
                name: symbol
            };
        });
        
        return plotData;
    }
    
    // Plot the time series data
    
    // 1. Price Series (original_data)
    if (results.original_data && Array.isArray(results.original_data) && results.original_data.length > 0) {
        const priceSeriesPlotData = transformArrayToPlotData(results.original_data);
        
        if (priceSeriesPlotData) {
            const priceSeriesPlot = document.getElementById('price-series-plot');
            Plotly.newPlot(priceSeriesPlot, priceSeriesPlotData, {
                title: 'Price Series',
                xaxis: { title: 'Date' },
                yaxis: { title: 'Price' },
                legend: { orientation: 'h', y: -0.2 }
            });
            console.log("Price series plot created with", priceSeriesPlotData.length, "traces");
        }
    } else {
        console.log("No original data available for plotting");
        document.getElementById('price-series-plot').innerHTML = 
            '<div class="alert alert-warning">No price data available</div>';
    }
    
    // 2. Returns Series (returns_data)
    if (results.returns_data && Array.isArray(results.returns_data) && results.returns_data.length > 0) {
        const returnsPlotData = transformArrayToPlotData(results.returns_data);
        
        if (returnsPlotData) {
            const returnsSeriesPlot = document.getElementById('returns-series-plot');
            Plotly.newPlot(returnsSeriesPlot, returnsPlotData, {
                title: 'Returns Series',
                xaxis: { title: 'Date' },
                yaxis: { title: 'Return' },
                legend: { orientation: 'h', y: -0.2 }
            });
            console.log("Returns series plot created with", returnsPlotData.length, "traces");
        }
    } else {
        console.log("No returns data available for plotting");
        document.getElementById('returns-series-plot').innerHTML = 
            '<div class="alert alert-warning">No returns data available</div>';
    }
    
    // 3. GARCH Series (post_garch_data)
    if (results.post_garch_data && Array.isArray(results.post_garch_data) && results.post_garch_data.length > 0) {
        const garchPlotData = transformArrayToPlotData(results.post_garch_data);
        
        if (garchPlotData) {
            const garchSeriesPlot = document.getElementById('garch-series-plot');
            Plotly.newPlot(garchSeriesPlot, garchPlotData, {
                title: 'Scaled for GARCH Series',
                xaxis: { title: 'Date' },
                yaxis: { title: 'Value' },
                legend: { orientation: 'h', y: -0.2 }
            });
            console.log("GARCH series plot created with", garchPlotData.length, "traces");
        }
    } else {
        console.log("No GARCH data available for plotting");
        document.getElementById('garch-series-plot').innerHTML = 
            '<div class="alert alert-warning">No scaled GARCH data available</div>';
    }
    
    // Populate stationarity tab
    if (results.stationarity_results) {
        const stationarityResults = results.stationarity_results;
        
        document.getElementById('stationarity-interpretation').textContent = stationarityResults.interpretation;
        document.getElementById('adf-statistic').textContent = stationarityResults.adf_statistic.toFixed(4);
        document.getElementById('p-value').textContent = stationarityResults.p_value.toFixed(4);
        document.getElementById('is-stationary').textContent = stationarityResults.is_stationary ? 'Yes' : 'No';
        
        // Set alert class based on stationarity
        const stationarityAlert = document.getElementById('stationarity-alert');
        stationarityAlert.className = stationarityResults.is_stationary ? 
            'alert alert-success' : 'alert alert-warning';
        
        // Populate critical values table
        const criticalValuesTable = document.getElementById('critical-values-table').getElementsByTagName('tbody')[0];
        criticalValuesTable.innerHTML = ''; // Clear any existing rows
        
        for (const [level, value] of Object.entries(stationarityResults.critical_values)) {
            const row = criticalValuesTable.insertRow();
            const levelCell = row.insertCell(0);
            const valueCell = row.insertCell(1);
            
            levelCell.textContent = level;
            valueCell.textContent = value.toFixed(4);
        }
    } else {
        console.error("No stationarity results found");
        document.getElementById('stationarity-interpretation').textContent = "Stationarity test results not available";
        const stationarityAlert = document.getElementById('stationarity-alert');
        stationarityAlert.className = 'alert alert-warning';
        stationarityAlert.innerHTML = '<strong>Error:</strong> Stationarity test results not available';
    }
    
    // Populate ARIMA tab
    if (results.arima_summary) {
        document.getElementById('arima-summary').textContent = results.arima_summary;
        
        // Create ARIMA forecast plot if forecast data is available
        if (results.arima_forecast && results.arima_forecast.length > 0) {
            const arimaForecastPlot = document.getElementById('arima-forecast-plot');
            Plotly.newPlot(arimaForecastPlot, [{
                x: Array.from({ length: results.arima_forecast.length }, (_, i) => i + 1),
                y: results.arima_forecast,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'ARIMA Forecast'
            }], {
                title: 'ARIMA Forecast',
                xaxis: { title: 'Time Horizon (Days)' },
                yaxis: { title: 'Value' }
            });
        } else {
            document.getElementById('arima-forecast-plot').innerHTML = 
                '<div class="alert alert-warning">No ARIMA forecast data available</div>';
        }
    } else {
        console.error("No ARIMA summary found");
        document.getElementById('arima-summary').textContent = "ARIMA model results not available";
    }
    
    // Populate GARCH tab
    if (results.garch_summary) {
        document.getElementById('garch-summary').textContent = results.garch_summary;
        
        // Create GARCH forecast plot if forecast data is available
        if (results.garch_forecast && results.garch_forecast.length > 0) {
            const garchForecastPlot = document.getElementById('garch-forecast-plot');
            Plotly.newPlot(garchForecastPlot, [{
                x: Array.from({ length: results.garch_forecast.length }, (_, i) => i + 1),
                y: results.garch_forecast,
                type: 'scatter',
                mode: 'lines+markers',
                name: 'GARCH Forecast'
            }], {
                title: 'Volatility Forecast',
                xaxis: { title: 'Time Horizon (Days)' },
                yaxis: { title: 'Value' }
            });
        } else {
            document.getElementById('garch-forecast-plot').innerHTML = 
                '<div class="alert alert-warning">No GARCH forecast data available</div>';
        }
    } else {
        console.error("No GARCH summary found");
        document.getElementById('garch-summary').textContent = "GARCH model results not available";
    }
    
    // Helper function to create data tables from array data
    function updateDataTable(tableId, dataArray, dateField = 'Date') {
        const table = document.getElementById(tableId);
        if (!table) {
            console.error(`Table with ID ${tableId} not found`);
            return;
        }
        
        const tableHead = table.getElementsByTagName('thead')[0];
        const tableBody = table.getElementsByTagName('tbody')[0];
        
        if (!tableHead || !tableBody) {
            console.error("Table head or body not found");
            return;
        }
        
        // Clear existing content
        tableBody.innerHTML = '';
        
        // Get all symbols (exclude the date field)
        const firstItem = dataArray[0];
        const symbols = Object.keys(firstItem).filter(key => key !== dateField);
        
        // Update table header with symbol columns
        let headerHTML = '<tr><th>Date</th>';
        symbols.forEach(symbol => {
            headerHTML += `<th>${symbol}</th>`;
        });
        headerHTML += '</tr>';
        tableHead.innerHTML = headerHTML;
        
        // Add rows for each data point
        dataArray.forEach(item => {
            const row = tableBody.insertRow();
            const dateCell = row.insertCell(0);
            if (item[dateField]) {
                dateCell.textContent = item[dateField].split('T')[0]; // Remove time part
            } else {
                dateCell.textContent = 'N/A';
            }
            
            // Add values for each symbol
            symbols.forEach((symbol, index) => {
                const valueCell = row.insertCell(index + 1);
                if (item[symbol] !== undefined) {
                    const value = item[symbol];
                    valueCell.textContent = typeof value === 'number' ? value.toFixed(4) : value;
                } else {
                    valueCell.textContent = 'N/A';
                }
            });
        });
    }
    
    // Update data tables in the Provenance tab
    if (results.original_data && Array.isArray(results.original_data)) {
        updateDataTable('price-data-table', results.original_data);
    }
    
    if (results.returns_data && Array.isArray(results.returns_data)) {
        updateDataTable('returns-data-table', results.returns_data);
    }
    
    if (results.post_garch_data && Array.isArray(results.post_garch_data)) {
        updateDataTable('garch-data-table', results.post_garch_data);
    }
    
    // Setup CSV export buttons
    function setupExportButton(buttonId, dataArray, filename, dateField = 'Date') {
        const button = document.getElementById(buttonId);
        if (!button) {
            console.error(`Button with ID ${buttonId} not found`);
            return;
        }
        
        button.addEventListener('click', function() {
            if (!dataArray || !Array.isArray(dataArray) || dataArray.length === 0) {
                alert('No data available for export');
                return;
            }
            
            // Get headers
            const headers = Object.keys(dataArray[0]);
            
            // Create CSV content
            let csvContent = headers.join(',') + '\n';
            
            dataArray.forEach(item => {
                const row = headers.map(header => {
                    const value = item[header];
                    // Handle numbers, strings, nulls, etc.
                    const formatted = (value === null || value === undefined) ? '' : 
                                    (typeof value === 'number') ? value.toString() : `"${value}"`;
                    return formatted;
                });
                csvContent += row.join(',') + '\n';
            });
            
            // Create download link
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.setAttribute('href', url);
            link.setAttribute('download', `${filename}.csv`);
            link.style.visibility = 'hidden';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });
    }
    
    // Setup export buttons
    if (results.original_data) {
        setupExportButton('export-price-csv', results.original_data, 'price_series');
    }
    
    if (results.returns_data) {
        setupExportButton('export-returns-csv', results.returns_data, 'returns_series');
    }
    
    if (results.post_garch_data) {
        setupExportButton('export-garch-csv', results.post_garch_data, 'garch_series');
    }
    
    // Resize plots when tabs are shown
    const tabElements = document.querySelectorAll('button[data-bs-toggle="tab"]');
    tabElements.forEach(tab => {
        tab.addEventListener('shown.bs.tab', function() {
            console.log("Tab changed, triggering resize");
            window.dispatchEvent(new Event('resize'));
        });
    });
});

document.getElementById('download-data-btn').addEventListener('click', function() {
  const resultsJson = sessionStorage.getItem('analysisResults');
  if (!resultsJson) {
    alert('No analysis results found in session storage');
    return;
  }
  
  try {
    const results = JSON.parse(resultsJson);
    const dataStr = JSON.stringify(results, null, 2);
    const dataUri = 'data:text/plain;charset=utf-8,' + encodeURIComponent(dataStr);
    
    const exportName = 'analysis_results_' + new Date().toISOString().slice(0, 19).replace(/:/g, '-') + '.txt';
    
    const linkElement = document.createElement('a');
    linkElement.setAttribute('href', dataUri);
    linkElement.setAttribute('download', exportName);
    linkElement.style.display = 'none';
    document.body.appendChild(linkElement);
    linkElement.click();
    document.body.removeChild(linkElement);
  } catch (error) {
    console.error('Error exporting data:', error);
    alert('Error exporting data: ' + error.message);
  }
});

</script>
{% endblock %}
