<!-- templates/timeseries/results.html -->

{% extends 'base.html' %}
{% load static %}

{% block title %}Results - Timeseries Pipeline{% endblock %}

{% block content %}
<h1 class="mb-4">Analysis Results</h1>

<div id="no-results" class="alert alert-warning" style="display: none;">
    <p>No analysis results found. Please run an analysis first.</p>
    <a href="{% url 'timeseries:analysis' %}" class="btn btn-primary">Go to Analysis</a>
</div>

<div id="results-container" style="display: none;">
    <ul class="nav nav-tabs mb-4" id="resultsTabs" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="time-series-tab" data-bs-toggle="tab" data-bs-target="#time-series" 
                    type="button" role="tab" aria-controls="time-series" aria-selected="true">
                Time Series
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="stationarity-tab" data-bs-toggle="tab" data-bs-target="#stationarity" 
                    type="button" role="tab" aria-controls="stationarity" aria-selected="false">
                Stationarity
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="arima-tab" data-bs-toggle="tab" data-bs-target="#arima" 
                    type="button" role="tab" aria-controls="arima" aria-selected="false">
                ARIMA
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="garch-tab" data-bs-toggle="tab" data-bs-target="#garch" 
                    type="button" role="tab" aria-controls="garch" aria-selected="false">
                GARCH
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="data-tab" data-bs-toggle="tab" data-bs-target="#data" 
                    type="button" role="tab" aria-controls="data" aria-selected="false">
                Raw Data
            </button>
        </li>
    </ul>
    
    <div class="tab-content" id="resultsTabsContent">
        <!-- Time Series Tab -->
        <div class="tab-pane fade show active" id="time-series" role="tabpanel" aria-labelledby="time-series-tab">
            <!-- Price Series Plot -->
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Price Series</h5>
                </div>
                <div class="card-body">
                    <div id="price-series-plot" style="height: 400px;"></div>
                </div>
            </div>
            
            <!-- Returns Series Plot -->
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Returns Series</h5>
                </div>
                <div class="card-body">
                    <div id="returns-series-plot" style="height: 400px;"></div>
                </div>
            </div>
            
            <!-- GARCH Series Plot -->
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Scaled for GARCH Series</h5>
                </div>
                <div class="card-body">
                    <div id="garch-series-plot" style="height: 400px;"></div>
                </div>
            </div>
        </div>
        
        <!-- Stationarity Tab -->
        <div class="tab-pane fade" id="stationarity" role="tabpanel" aria-labelledby="stationarity-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">Stationarity Test Results</h5>
                </div>
                <div class="card-body">
                    <div class="alert" id="stationarity-alert">
                        <strong>Interpretation:</strong> <span id="stationarity-interpretation"></span>
                    </div>
                    
                    <h6>ADF Test Results</h6>
                    <table class="table table-bordered">
                        <tbody>
                            <tr>
                                <th>ADF Statistic</th>
                                <td id="adf-statistic"></td>
                            </tr>
                            <tr>
                                <th>p-value</th>
                                <td id="p-value"></td>
                            </tr>
                            <tr>
                                <th>Is Stationary</th>
                                <td id="is-stationary"></td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <h6>Critical Values</h6>
                    <table class="table table-bordered" id="critical-values-table">
                        <thead>
                            <tr>
                                <th>Significance Level</th>
                                <th>Critical Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Will be filled dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- ARIMA Tab -->
        <div class="tab-pane fade" id="arima" role="tabpanel" aria-labelledby="arima-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">ARIMA Model Results</h5>
                </div>
                <div class="card-body">
                    <h6>Model Summary</h6>
                    <pre id="arima-summary" class="p-3 bg-light rounded"></pre>
                    
                    <h6>Forecast</h6>
                    <div id="arima-forecast-plot" style="height: 400px;"></div>
                </div>
            </div>
        </div>
        
        <!-- GARCH Tab -->
        <div class="tab-pane fade" id="garch" role="tabpanel" aria-labelledby="garch-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">GARCH Model Results</h5>
                </div>
                <div class="card-body">
                    <h6>Model Summary</h6>
                    <pre id="garch-summary" class="p-3 bg-light rounded"></pre>
                    
                    <h6>Volatility Forecast</h6>
                    <div id="garch-forecast-plot" style="height: 400px;"></div>
                </div>
            </div>
        </div>
        
        <!-- Raw Data Tab -->
        <div class="tab-pane fade" id="data" role="tabpanel" aria-labelledby="data-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <ul class="nav nav-tabs card-header-tabs" id="datasetTabs" role="tablist">
                        <li class="nav-item" role="presentation">
                            <button class="nav-link active" id="price-data-tab" data-bs-toggle="tab" data-bs-target="#price-data" 
                                    type="button" role="tab" aria-controls="price-data" aria-selected="true">
                                Price Series
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="returns-data-tab" data-bs-toggle="tab" data-bs-target="#returns-data" 
                                    type="button" role="tab" aria-controls="returns-data" aria-selected="false">
                                Returns Series
                            </button>
                        </li>
                        <li class="nav-item" role="presentation">
                            <button class="nav-link" id="garch-data-tab" data-bs-toggle="tab" data-bs-target="#garch-data" 
                                    type="button" role="tab" aria-controls="garch-data" aria-selected="false">
                                Scaled for GARCH
                            </button>
                        </li>
                    </ul>
                </div>
                <div class="card-body">
                    <div class="tab-content" id="datasetTabContent">
                        <!-- Price Series Data -->
                        <div class="tab-pane fade show active" id="price-data" role="tabpanel" aria-labelledby="price-data-tab">
                            <div class="d-flex justify-content-end mb-3">
                                <button class="btn btn-outline-primary" id="export-price-csv">
                                    <i class="bi bi-download"></i> Export as CSV
                                </button>
                            </div>
                            <div class="table-responsive">
                                <table class="table table-striped table-hover" id="price-data-table">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <!-- Dynamically filled -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Dynamically filled -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- Returns Series Data -->
                        <div class="tab-pane fade" id="returns-data" role="tabpanel" aria-labelledby="returns-data-tab">
                            <div class="d-flex justify-content-end mb-3">
                                <button class="btn btn-outline-primary" id="export-returns-csv">
                                    <i class="bi bi-download"></i> Export as CSV
                                </button>
                            </div>
                            <div class="table-responsive">
                                <table class="table table-striped table-hover" id="returns-data-table">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <!-- Dynamically filled -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Dynamically filled -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                        
                        <!-- GARCH Series Data -->
                        <div class="tab-pane fade" id="garch-data" role="tabpanel" aria-labelledby="garch-data-tab">
                            <div class="d-flex justify-content-end mb-3">
                                <button class="btn btn-outline-primary" id="export-garch-csv">
                                    <i class="bi bi-download"></i> Export as CSV
                                </button>
                            </div>
                            <div class="table-responsive">
                                <table class="table table-striped table-hover" id="garch-data-table">
                                    <thead>
                                        <tr>
                                            <th>Date</th>
                                            <!-- Dynamically filled -->
                                        </tr>
                                    </thead>
                                    <tbody>
                                        <!-- Dynamically filled -->
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Try to get analysis results from sessionStorage
        const resultsJson = sessionStorage.getItem('analysisResults');
        
        if (!resultsJson) {
            // No results found, show message
            document.getElementById('no-results').style.display = 'block';
            document.getElementById('results-container').style.display = 'none';
            return;
        }
        
        // Parse results JSON
        const results = JSON.parse(resultsJson);
        console.log("Results data:", results); // Debug: Log the results object structure
        
        // Show results container
        document.getElementById('no-results').style.display = 'none';
        document.getElementById('results-container').style.display = 'block';
        
        function transformAPIData(apiData) {
            // If we don't have data or it's not an array, return an empty object
            if (!apiData || !Array.isArray(apiData)) {
                console.error("Invalid API data format:", apiData);
                return {};
            }
            
            console.log("Transforming data:", apiData);
            
            // Create the expected structure
            const transformed = {};
            
            // Convert array format to the expected object format
            apiData.forEach((item, index) => {
                // Skip if the item is not properly formatted
                if (!item || typeof item !== 'object') {
                    console.warn(`Skipping invalid item at index ${index}:`, item);
                    return;
                }
                
                // Check for either 'index' or 'Date' field
                const dateField = item.index || item.Date;
                
                // Handle case where date field might be missing
                if (!dateField) {
                    console.warn(`Item at index ${index} is missing date field:`, item);
                    return;
                }
                
                try {
                    // Extract date from the date field (removing time part)
                    const date = dateField.split('T')[0];
                    
                    // Create entry for this date
                    transformed[date] = {};
                    
                    // Add all symbol values except the date field
                    Object.keys(item).forEach(key => {
                        if (key !== 'index' && key !== 'Date') {
                            transformed[date][key] = item[key];
                        }
                    });
                } catch (error) {
                    console.error(`Error processing item at index ${index}:`, error, item);
                }
            });
            
            console.log("Transformed data:", transformed);
            return transformed;
        }

        // Extract time series data from the API response
        let timeSeriesData = null;

        // Log the entire results object to see its structure
        console.log("Full results object:", results);

        // Check for different potential data structures from the API
        if (results.data && typeof results.data === 'object') {
            timeSeriesData = results.data;
            console.log("Using 'data' property");
        } else if (results.time_series_data && typeof results.time_series_data === 'object') {
            timeSeriesData = results.time_series_data;
            console.log("Using 'time_series_data' property");
        } else if (results.historical_data && typeof results.historical_data === 'object') {
            timeSeriesData = results.historical_data;
            console.log("Using 'historical_data' property");
        } else if (results.original_data && Array.isArray(results.original_data)) {
            console.log("Using 'original_data' property:", results.original_data);
            // Transform the array format to the expected object format
            timeSeriesData = transformAPIData(results.original_data);
        } else {
            console.error("No valid data found in results");
        }

        console.log("Final timeSeriesData:", timeSeriesData);

        if (timeSeriesData) {
            // Get all available dates (sorted)
            const dates = Object.keys(timeSeriesData).sort();
            
            if (dates.length > 0) {
                // Get all symbols from the first date, excluding "Date"
                const firstDate = dates[0];
                const symbols = Object.keys(timeSeriesData[firstDate] || {})
                    .filter(key => key !== "Date" && key !== "index");
                
                console.log("Found symbols:", symbols);
                
                if (symbols.length > 0) {
                    // Create plot data for price series
                    const plotData = symbols.map(symbol => {
                        const x = [];
                        const y = [];
                        
                        // Collect data points for this symbol
                        dates.forEach(date => {
                            if (timeSeriesData[date] && timeSeriesData[date][symbol] !== undefined) {
                                x.push(date);
                                y.push(timeSeriesData[date][symbol]);
                            }
                        });
                        
                        return {
                            x: x,
                            y: y,
                            type: 'scatter',
                            mode: 'lines',
                            name: symbol
                        };
                    });
                    
                    // Create the price series plot
                    const priceSeriesPlot = document.getElementById('price-series-plot');
                    Plotly.newPlot(priceSeriesPlot, plotData, {
                        title: 'Price Series',
                        xaxis: { title: 'Date' },
                        yaxis: { title: 'Price' },
                        legend: { orientation: 'h', y: -0.2 }
                    });
                    
                    console.log("Price series plot created with", plotData.length, "traces");
                    
                    // Create the returns series plot if available
                    if (results.returns_data && Array.isArray(results.returns_data) && results.returns_data.length > 0) {
                        // Transform returns data
                        const returnsData = transformAPIData(results.returns_data);
                        const returnsDates = Object.keys(returnsData).sort();
                        
                        if (returnsDates.length > 0) {
                            const returnsSymbols = Object.keys(returnsData[returnsDates[0]] || {})
                                .filter(key => key !== "Date" && key !== "index");
                            
                            // Create plot data for returns series
                            const returnsPlotData = returnsSymbols.map(symbol => {
                                const x = [];
                                const y = [];
                                
                                // Collect data points for this symbol
                                returnsDates.forEach(date => {
                                    if (returnsData[date] && returnsData[date][symbol] !== undefined) {
                                        x.push(date);
                                        y.push(returnsData[date][symbol]);
                                    }
                                });
                                
                                return {
                                    x: x,
                                    y: y,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: symbol
                                };
                            });
                            
                            const returnsSeriesPlot = document.getElementById('returns-series-plot');
                            Plotly.newPlot(returnsSeriesPlot, returnsPlotData, {
                                title: 'Returns Series',
                                xaxis: { title: 'Date' },
                                yaxis: { title: 'Return' },
                                legend: { orientation: 'h', y: -0.2 }
                            });
                            
                            console.log("Returns series plot created with", returnsPlotData.length, "traces");
                        }
                    } else {
                        console.log("No returns data available for plotting");
                        document.getElementById('returns-series-plot').innerHTML = 
                            '<div class="alert alert-warning">No returns data available</div>';
                    }
                    
                    // Create the GARCH series plot if available
                    if (results.post_garch_data && Array.isArray(results.post_garch_data) && results.post_garch_data.length > 0) {
                        // Transform GARCH data
                        const garchData = transformAPIData(results.post_garch_data);
                        const garchDates = Object.keys(garchData).sort();
                        
                        if (garchDates.length > 0) {
                            const garchSymbols = Object.keys(garchData[garchDates[0]] || {})
                                .filter(key => key !== "Date" && key !== "index");
                            
                            // Create plot data for GARCH series
                            const garchPlotData = garchSymbols.map(symbol => {
                                const x = [];
                                const y = [];
                                
                                // Collect data points for this symbol
                                garchDates.forEach(date => {
                                    if (garchData[date] && garchData[date][symbol] !== undefined) {
                                        x.push(date);
                                        y.push(garchData[date][symbol]);
                                    }
                                });
                                
                                return {
                                    x: x,
                                    y: y,
                                    type: 'scatter',
                                    mode: 'lines',
                                    name: symbol
                                };
                            });
                            
                            const garchSeriesPlot = document.getElementById('garch-series-plot');
                            Plotly.newPlot(garchSeriesPlot, garchPlotData, {
                                title: 'Scaled for GARCH Series',
                                xaxis: { title: 'Date' },
                                yaxis: { title: 'Value' },
                                legend: { orientation: 'h', y: -0.2 }
                            });
                            
                            console.log("GARCH series plot created with", garchPlotData.length, "traces");
                        }
                    } else {
                        console.log("No GARCH data available for plotting");
                        document.getElementById('garch-series-plot').innerHTML = 
                            '<div class="alert alert-warning">No scaled GARCH data available</div>';
                    }
                    
                    // Update the raw data table with all symbols
                    updateRawDataTable(timeSeriesData, dates, symbols);
                    
                    // Hide the symbol selectors since we're showing all symbols
                    const symbolSelector = document.getElementById('symbol-selector');
                    const dataSymbolSelector = document.getElementById('data-symbol-selector');
                    if (symbolSelector) symbolSelector.style.display = 'none';
                    if (dataSymbolSelector) dataSymbolSelector.style.display = 'none';
                } else {
                    console.error("No valid symbols found in time series data");
                }
            } else {
                console.error("No dates found in time series data");
            }
        } else {
            console.error("No time series data found in results");
        }

        // Function to update raw data table
        function updateRawDataTable(timeSeriesData, dates, symbols) {
            const tableBody = document.getElementById('raw-data-table').getElementsByTagName('tbody')[0];
            const tableHead = document.getElementById('raw-data-table').getElementsByTagName('thead')[0];
            
            // Clear existing content
            tableBody.innerHTML = '';
            
            if (!tableHead || !tableBody) {
                console.error("Table elements not found");
                return;
            }
            
            // Update table header with symbol columns
            let headerHTML = '<tr><th>Date</th>';
            symbols.forEach(symbol => {
                headerHTML += `<th>${symbol}</th>`;
            });
            headerHTML += '</tr>';
            tableHead.innerHTML = headerHTML;
            
            // Add rows for each date
            dates.forEach(date => {
                const row = tableBody.insertRow();
                const dateCell = row.insertCell(0);
                dateCell.textContent = date;
                
                // Add values for each symbol
                symbols.forEach((symbol, index) => {
                    const valueCell = row.insertCell(index + 1);
                    if (timeSeriesData[date] && timeSeriesData[date][symbol] !== undefined) {
                        const value = timeSeriesData[date][symbol];
                        valueCell.textContent = typeof value === 'number' ? value.toFixed(4) : value;
                    } else {
                        valueCell.textContent = 'N/A';
                    }
                });
            });
        }
        
        // Populate stationarity tab
        if (results.stationarity_results) {
            const stationarityResults = results.stationarity_results;
            
            document.getElementById('stationarity-interpretation').textContent = stationarityResults.interpretation;
            document.getElementById('adf-statistic').textContent = stationarityResults.adf_statistic.toFixed(4);
            document.getElementById('p-value').textContent = stationarityResults.p_value.toFixed(4);
            document.getElementById('is-stationary').textContent = stationarityResults.is_stationary ? 'Yes' : 'No';
            
            // Set alert class based on stationarity
            const stationarityAlert = document.getElementById('stationarity-alert');
            stationarityAlert.className = stationarityResults.is_stationary ? 
                'alert alert-success' : 'alert alert-warning';
            
            // Populate critical values table
            const criticalValuesTable = document.getElementById('critical-values-table').getElementsByTagName('tbody')[0];
            criticalValuesTable.innerHTML = ''; // Clear any existing rows
            
            for (const [level, value] of Object.entries(stationarityResults.critical_values)) {
                const row = criticalValuesTable.insertRow();
                const levelCell = row.insertCell(0);
                const valueCell = row.insertCell(1);
                
                levelCell.textContent = level;
                valueCell.textContent = value.toFixed(4);
            }
        }
        
        // Populate ARIMA tab
        if (results.arima_summary) {
            document.getElementById('arima-summary').textContent = results.arima_summary;
            
            // Create ARIMA forecast plot if forecast data is available
            if (results.arima_forecast && results.arima_forecast.length > 0) {
                const arimaForecastPlot = document.getElementById('arima-forecast-plot');
                Plotly.newPlot(arimaForecastPlot, [{
                    x: Array.from({ length: results.arima_forecast.length }, (_, i) => i + 1),
                    y: results.arima_forecast,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'ARIMA Forecast'
                }], {
                    title: 'ARIMA Forecast',
                    xaxis: { title: 'Time Horizon (Days)' },
                    yaxis: { title: 'Value' }
                });
            }
        }
        
        // Populate GARCH tab
        if (results.garch_summary) {
            document.getElementById('garch-summary').textContent = results.garch_summary;
            
            // Create GARCH forecast plot if forecast data is available
            if (results.garch_forecast && results.garch_forecast.length > 0) {
                const garchForecastPlot = document.getElementById('garch-forecast-plot');
                Plotly.newPlot(garchForecastPlot, [{
                    x: Array.from({ length: results.garch_forecast.length }, (_, i) => i + 1),
                    y: results.garch_forecast,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'GARCH Forecast'
                }], {
                    title: 'Volatility Forecast',
                    xaxis: { title: 'Time Horizon (Days)' },
                    yaxis: { title: 'Value' }
                });
            }
        }
        
        // Resize plots when tabs are shown
        const tabElements = document.querySelectorAll('button[data-bs-toggle="tab"]');
        tabElements.forEach(tab => {
            tab.addEventListener('shown.bs.tab', function() {
                console.log("Tab changed, triggering resize"); // Debug: Log tab change
                window.dispatchEvent(new Event('resize'));
            });
        });
    });
</script>
{% endblock %}
