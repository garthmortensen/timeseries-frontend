<!-- templates/timeseries/results.html -->

{% extends 'base.html' %}
{% load static %}

{% block title %}Results - Timeseries Pipeline{% endblock %}

{% block content %}
<h1 class="mb-4">Analysis Results</h1>

<div id="no-results" class="alert alert-warning" style="display: none;">
    <p>No analysis results found. Please run an analysis first.</p>
    <a href="{% url 'timeseries:analysis' %}" class="btn btn-primary">Go to Analysis</a>
</div>

<div id="results-container" style="display: none;">
    <ul class="nav nav-tabs mb-4" id="resultsTabs" role="tablist">
        <li class="nav-item" role="presentation">
            <button class="nav-link active" id="time-series-tab" data-bs-toggle="tab" data-bs-target="#time-series" 
                    type="button" role="tab" aria-controls="time-series" aria-selected="true">
                Time Series
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="stationarity-tab" data-bs-toggle="tab" data-bs-target="#stationarity" 
                    type="button" role="tab" aria-controls="stationarity" aria-selected="false">
                Stationarity
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="arima-tab" data-bs-toggle="tab" data-bs-target="#arima" 
                    type="button" role="tab" aria-controls="arima" aria-selected="false">
                ARIMA
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="garch-tab" data-bs-toggle="tab" data-bs-target="#garch" 
                    type="button" role="tab" aria-controls="garch" aria-selected="false">
                GARCH
            </button>
        </li>
        <li class="nav-item" role="presentation">
            <button class="nav-link" id="data-tab" data-bs-toggle="tab" data-bs-target="#data" 
                    type="button" role="tab" aria-controls="data" aria-selected="false">
                Raw Data
            </button>
        </li>
    </ul>
    
    <div class="tab-content" id="resultsTabsContent">
        <!-- Time Series Tab -->
        <div class="tab-pane fade show active" id="time-series" role="tabpanel" aria-labelledby="time-series-tab">
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Time Series Plot</h5>
                    <div>
                        <select id="symbol-selector" class="form-select form-select-sm" style="width: auto; display: inline-block;">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                </div>
                <div class="card-body">
                    <div id="time-series-plot" style="height: 500px;"></div>
                </div>
            </div>
        </div>
        
        <!-- Stationarity Tab -->
        <div class="tab-pane fade" id="stationarity" role="tabpanel" aria-labelledby="stationarity-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">Stationarity Test Results</h5>
                </div>
                <div class="card-body">
                    <div class="alert" id="stationarity-alert">
                        <strong>Interpretation:</strong> <span id="stationarity-interpretation"></span>
                    </div>
                    
                    <h6>ADF Test Results</h6>
                    <table class="table table-bordered">
                        <tbody>
                            <tr>
                                <th>ADF Statistic</th>
                                <td id="adf-statistic"></td>
                            </tr>
                            <tr>
                                <th>p-value</th>
                                <td id="p-value"></td>
                            </tr>
                            <tr>
                                <th>Is Stationary</th>
                                <td id="is-stationary"></td>
                            </tr>
                        </tbody>
                    </table>
                    
                    <h6>Critical Values</h6>
                    <table class="table table-bordered" id="critical-values-table">
                        <thead>
                            <tr>
                                <th>Significance Level</th>
                                <th>Critical Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <!-- Will be filled dynamically -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <!-- ARIMA Tab -->
        <div class="tab-pane fade" id="arima" role="tabpanel" aria-labelledby="arima-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">ARIMA Model Results</h5>
                </div>
                <div class="card-body">
                    <h6>Model Summary</h6>
                    <pre id="arima-summary" class="p-3 bg-light rounded"></pre>
                    
                    <h6>Forecast</h6>
                    <div id="arima-forecast-plot" style="height: 400px;"></div>
                </div>
            </div>
        </div>
        
        <!-- GARCH Tab -->
        <div class="tab-pane fade" id="garch" role="tabpanel" aria-labelledby="garch-tab">
            <div class="card mb-4">
                <div class="card-header">
                    <h5 class="card-title mb-0">GARCH Model Results</h5>
                </div>
                <div class="card-body">
                    <h6>Model Summary</h6>
                    <pre id="garch-summary" class="p-3 bg-light rounded"></pre>
                    
                    <h6>Volatility Forecast</h6>
                    <div id="garch-forecast-plot" style="height: 400px;"></div>
                </div>
            </div>
        </div>
        
        <!-- Raw Data Tab -->
        <div class="tab-pane fade" id="data" role="tabpanel" aria-labelledby="data-tab">
            <div class="card mb-4">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <h5 class="card-title mb-0">Raw Time Series Data</h5>
                    <div>
                        <select id="data-symbol-selector" class="form-select form-select-sm" style="width: auto; display: inline-block;">
                            <!-- Will be populated dynamically -->
                        </select>
                    </div>
                </div>
                <div class="card-body">
                    <div class="table-responsive">
                        <table class="table table-striped table-hover" id="raw-data-table">
                            <thead>
                                <tr>
                                    <th>Date</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody>
                                <!-- Will be filled dynamically -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // Try to get analysis results from sessionStorage
        const resultsJson = sessionStorage.getItem('analysisResults');
        
        if (!resultsJson) {
            // No results found, show message
            document.getElementById('no-results').style.display = 'block';
            document.getElementById('results-container').style.display = 'none';
            return;
        }
        
        // Parse results JSON
        const results = JSON.parse(resultsJson);
        console.log("Results data:", results); // Debug: Log the results object structure
        
        // Show results container
        document.getElementById('no-results').style.display = 'none';
        document.getElementById('results-container').style.display = 'block';
            
        // Extract time series data from the API response
        let timeSeriesData = null;
        
        // Check for different potential data structures from the API
        if (results.data && typeof results.data === 'object') {
            timeSeriesData = results.data;
        } else if (results.time_series_data && typeof results.time_series_data === 'object') {
            timeSeriesData = results.time_series_data;
        } else if (results.historical_data && typeof results.historical_data === 'object') {
            timeSeriesData = results.historical_data;
        } else if (results.original_data && typeof results.original_data === 'object') {
            timeSeriesData = results.original_data;
        }
        
        console.log("Time series data structure:", timeSeriesData);
        
        if (timeSeriesData) {
            // Update the time series plot with all symbols at once
            updateTimeSeriesPlot(timeSeriesData);
            
            // Update the raw data table with all symbols
            updateRawDataTable(timeSeriesData);
            
            // We don't need symbol selectors anymore since we're showing all symbols
            // You can remove or hide the selector elements
            const symbolSelector = document.getElementById('symbol-selector');
            const dataSymbolSelector = document.getElementById('data-symbol-selector');
            if (symbolSelector) symbolSelector.style.display = 'none';
            if (dataSymbolSelector) dataSymbolSelector.style.display = 'none';
        } else {
            console.error("No time series data found in results");
        }

        // handle historical data
        function transformTimeSeriesData(data) {
            // Transform from date->symbol->value to symbol->date->value
            const transformed = {};
            
            // First, check if we have the expected structure
            if (typeof data !== 'object') return {};
            
            // Get all symbols from the first date entry (if it exists)
            const dates = Object.keys(data);
            if (dates.length === 0) return {};
            
            const firstDate = dates[0];
            const symbols = data[firstDate] ? Object.keys(data[firstDate]) : [];
            
            // Initialize the transformed object with empty objects for each symbol
            symbols.forEach(symbol => {
                transformed[symbol] = {};
            });
            
            // Populate the transformed object
            dates.forEach(date => {
                if (data[date]) {
                    symbols.forEach(symbol => {
                        if (data[date][symbol] !== undefined) {
                            transformed[symbol][date] = data[date][symbol];
                        }
                    });
                }
            });
            
            return transformed;
        }

        // Extract historical data from the API response
        let historicalData = {};

        // Check for different potential data structures from the API
        if (results.data && typeof results.data === 'object') {
            historicalData = transformTimeSeriesData(results.data);
        } else if (results.time_series_data && typeof results.time_series_data === 'object') {
            historicalData = transformTimeSeriesData(results.time_series_data);
        } else if (results.historical_data && typeof results.historical_data === 'object') {
            historicalData = transformTimeSeriesData(results.historical_data);
        } else if (results.original_data && typeof results.original_data === 'object') {
            historicalData = transformTimeSeriesData(results.original_data);
        }
        
        console.log("Historical data:", historicalData); // Debug: Log the historical data
        
        const symbols = Object.keys(historicalData);
        console.log("Symbols:", symbols); // Debug: Log the available symbols
        
        // Populate symbol selectors
        const symbolSelector = document.getElementById('symbol-selector');
        const dataSymbolSelector = document.getElementById('data-symbol-selector');
        
        symbolSelector.innerHTML = '';
        dataSymbolSelector.innerHTML = '';
        
        symbols.forEach(symbol => {
            symbolSelector.innerHTML += `<option value="${symbol}">${symbol}</option>`;
            dataSymbolSelector.innerHTML += `<option value="${symbol}">${symbol}</option>`;
        });
        
        // Set default symbol
        const defaultSymbol = symbols[0] || '';
        
        function updateTimeSeriesPlot(timeSeriesData) {
            const timeSeriesPlot = document.getElementById('time-series-plot');
            
            // Clear any existing plot
            Plotly.purge(timeSeriesPlot);
            
            // Check if we have valid data
            if (!timeSeriesData || typeof timeSeriesData !== 'object') {
                console.error("Invalid time series data:", timeSeriesData);
                return;
            }
            
            const dates = Object.keys(timeSeriesData).sort();
            if (dates.length === 0) {
                console.error("No dates found in time series data");
                return;
            }
            
            // Get all symbols from the first date
            const firstDate = dates[0];
            const symbols = timeSeriesData[firstDate] ? Object.keys(timeSeriesData[firstDate]) : [];
            console.log("Found symbols:", symbols);
            
            // Create a trace for each symbol
            const plotData = symbols.map(symbol => {
                const x = [];
                const y = [];
                
                // Collect data points for this symbol
                dates.forEach(date => {
                    if (timeSeriesData[date] && timeSeriesData[date][symbol] !== undefined) {
                        x.push(date);
                        y.push(timeSeriesData[date][symbol]);
                    }
                });
                
                return {
                    x: x,
                    y: y,
                    type: 'scatter',
                    mode: 'lines',
                    name: symbol
                };
            });
            
            const layout = {
                title: 'Time Series Plot',
                xaxis: { 
                    title: 'Date',
                    rangeselector: {
                        buttons: [
                            {count: 7, label: '1w', step: 'day', stepmode: 'backward'},
                            {count: 1, label: '1m', step: 'month', stepmode: 'backward'},
                            {count: 3, label: '3m', step: 'month', stepmode: 'backward'},
                            {count: 6, label: '6m', step: 'month', stepmode: 'backward'},
                            {step: 'all'}
                        ]
                    },
                    rangeslider: { visible: true }
                },
                yaxis: { title: 'Price' },
                legend: { orientation: 'h', y: -0.2 }
            };
            
            Plotly.newPlot(timeSeriesPlot, plotData, layout);
            console.log("Plot created with", plotData.length, "traces");
        }

        // Function to update raw data table
        function updateRawDataTable(timeSeriesData) {
            const tableBody = document.getElementById('raw-data-table').getElementsByTagName('tbody')[0];
            const tableHead = document.getElementById('raw-data-table').getElementsByTagName('thead')[0];
            
            // Clear existing content
            tableBody.innerHTML = '';
            
            // Check if we have valid data
            if (!timeSeriesData || typeof timeSeriesData !== 'object') {
                console.error("Invalid time series data for table");
                return;
            }
            
            const dates = Object.keys(timeSeriesData).sort();
            if (dates.length === 0) {
                console.error("No dates found in time series data for table");
                return;
            }
            
            // Get all symbols from the first date
            const firstDate = dates[0];
            const symbols = timeSeriesData[firstDate] ? Object.keys(timeSeriesData[firstDate]) : [];
            
            // Update table header with symbol columns
            let headerHTML = '<tr><th>Date</th>';
            symbols.forEach(symbol => {
                headerHTML += `<th>${symbol}</th>`;
            });
            headerHTML += '</tr>';
            tableHead.innerHTML = headerHTML;
            
            // Add rows for each date
            dates.forEach(date => {
                const row = tableBody.insertRow();
                const dateCell = row.insertCell(0);
                dateCell.textContent = date;
                
                // Add values for each symbol
                symbols.forEach((symbol, index) => {
                    const valueCell = row.insertCell(index + 1);
                    if (timeSeriesData[date] && timeSeriesData[date][symbol] !== undefined) {
                        const value = timeSeriesData[date][symbol];
                        valueCell.textContent = typeof value === 'number' ? value.toFixed(4) : value;
                    } else {
                        valueCell.textContent = 'N/A';
                    }
                });
            });
        }
        
        // Populate stationarity tab
        if (results.stationarity_results) {
            const stationarityResults = results.stationarity_results;
            
            document.getElementById('stationarity-interpretation').textContent = stationarityResults.interpretation;
            document.getElementById('adf-statistic').textContent = stationarityResults.adf_statistic.toFixed(4);
            document.getElementById('p-value').textContent = stationarityResults.p_value.toFixed(4);
            document.getElementById('is-stationary').textContent = stationarityResults.is_stationary ? 'Yes' : 'No';
            
            // Set alert class based on stationarity
            const stationarityAlert = document.getElementById('stationarity-alert');
            stationarityAlert.className = stationarityResults.is_stationary ? 
                'alert alert-success' : 'alert alert-warning';
            
            // Populate critical values table
            const criticalValuesTable = document.getElementById('critical-values-table').getElementsByTagName('tbody')[0];
            criticalValuesTable.innerHTML = ''; // Clear any existing rows
            
            for (const [level, value] of Object.entries(stationarityResults.critical_values)) {
                const row = criticalValuesTable.insertRow();
                const levelCell = row.insertCell(0);
                const valueCell = row.insertCell(1);
                
                levelCell.textContent = level;
                valueCell.textContent = value.toFixed(4);
            }
        }
        
        // Populate ARIMA tab
        if (results.arima_summary) {
            document.getElementById('arima-summary').textContent = results.arima_summary;
            
            // Create ARIMA forecast plot if forecast data is available
            if (results.arima_forecast && results.arima_forecast.length > 0) {
                const arimaForecastPlot = document.getElementById('arima-forecast-plot');
                Plotly.newPlot(arimaForecastPlot, [{
                    x: Array.from({ length: results.arima_forecast.length }, (_, i) => i + 1),
                    y: results.arima_forecast,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'ARIMA Forecast'
                }], {
                    title: 'ARIMA Forecast',
                    xaxis: { title: 'Time Horizon (Days)' },
                    yaxis: { title: 'Value' }
                });
            }
        }
        
        // Populate GARCH tab
        if (results.garch_summary) {
            document.getElementById('garch-summary').textContent = results.garch_summary;
            
            // Create GARCH forecast plot if forecast data is available
            if (results.garch_forecast && results.garch_forecast.length > 0) {
                const garchForecastPlot = document.getElementById('garch-forecast-plot');
                Plotly.newPlot(garchForecastPlot, [{
                    x: Array.from({ length: results.garch_forecast.length }, (_, i) => i + 1),
                    y: results.garch_forecast,
                    type: 'scatter',
                    mode: 'lines',
                    name: 'GARCH Forecast'
                }], {
                    title: 'Volatility Forecast',
                    xaxis: { title: 'Time Horizon (Days)' },
                    yaxis: { title: 'Value' }
                });
            }
        }
        
        // Initialize with default symbol if available
        if (defaultSymbol) {
            console.log("Initializing with default symbol:", defaultSymbol); // Debug: Log initialization
            updateTimeSeriesPlot(defaultSymbol);
            updateRawDataTable(defaultSymbol);
        } else {
            console.log("No default symbol available"); // Debug: Log when no symbol is available
        }
        
        // Set up event listeners for symbol selectors
        symbolSelector.addEventListener('change', function() {
            console.log("Symbol changed to:", this.value); // Debug: Log symbol change
            updateTimeSeriesPlot(this.value);
        });
        
        dataSymbolSelector.addEventListener('change', function() {
            console.log("Data symbol changed to:", this.value); // Debug: Log data symbol change
            updateRawDataTable(this.value);
        });
        
        // Resize plots when tabs are shown
        const tabElements = document.querySelectorAll('button[data-bs-toggle="tab"]');
        tabElements.forEach(tab => {
            tab.addEventListener('shown.bs.tab', function() {
                console.log("Tab changed, triggering resize"); // Debug: Log tab change
                window.dispatchEvent(new Event('resize'));
            });
        });
    });
</script>
{% endblock %}
